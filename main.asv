% 前轮反馈控制 Stanley法
clc
clear
close all
load path_S.mat
% load path_Circle.mat

%% 相关参数定义
RefPos = path;
targetSpeed = 10;           % 目标速度，单位： m /s
k = 5;                      % 增益参数
Kp = 0.8;                   % 速度P控制器系数
dt = 0.1;                   % 时间间隔，单位：s
L = 2.9;                    % 车辆轴距，单位：m

% 绘制参考轨迹
figure
plot(RefPos(:,1), RefPos(:,2), 'b', 'LineWidth', 2);
xlabel('纵向坐标 / m');
ylabel('横向坐标 / m');
grid on;
grid minor
axis equal
hold on 

% 计算轨迹的参考航向角-大地坐标系
diff_x = diff(RefPos(:,1)) ;
diff_x(end+1) = diff_x(end);
diff_y = diff(RefPos(:,2)) ;
diff_y(end+1) = diff_y(end);
RefHeading = atan2(diff_y ,diff_x);

%% 车辆初始状态
InitialState = [RefPos(1,:)+1, RefHeading(1)+0.02, 0];  % 纵向位置、横向位置、航向角、速度

% 将初始状态存入实际状态数组中
state = InitialState;
state_actual = state;

%% 主程序

% 循环遍历轨迹点
idx = 1;
latError_Stanley = [];
sizeOfRefPos = size(RefPos,1);
while idx < sizeOfRefPos
    % 寻找距离前轮中心最近的点
    idx = findTargetIdx(state, RefPos);

    % 计算前轮转角
    [delta, latError] = stanley_control(idx,state,RefPos,RefHeading,k);

    % 如果误差过大，退出循迹
    if abs(latError) > 3
        disp('误差过大，退出程序!\n')
        break
    end

    % 计算加速度
    a = Kp* (targetSpeed-state(4));
    
    % 更新状态量
    state_new = UpdateState(a,state,delta,dt,L);
    state = state_new;

    % 保存每一步的实际量
    state_actual(end+1,:) = state_new;
    latError_Stanley(end+1,:) =  [idx,latError];
end

% 画图
for i = 1:size(state_actual,1)
    % 实际位置
    scatter(state_actual(i,1), state_actual(i,2),150, 'r.');
    % 实际航向
    quiver(state_actual(i,1), state_actual(i,2), cos(state_actual(i,3)), sin(heading_actual(i,:)),0.5, 'm', 'LineWidth', 1);     % 实际航向
    pause(0.01)
end
legend('规划车辆轨迹', '实际行驶轨迹')

%  保存
path_stanley = state_actual(:,1:2);
save path_stanley.mat path_stanley;
save latError_Stanley.mat latError_Stanley

%% 子函数
function target_idx = findTargetIdx(state, RefPos)
    for i = 1:size(RefPos, 1)
        d(i, 1) = norm(state(1:2)-RefPos(i, :));
    end
    [~,target_idx] = min(d);  % 找到距离当前位置最近的一个参考轨迹点的序号
end

function [delta,latError] = stanley_control(idx,state,RefPos,RefHeading,k)
    % 根据百度Apolo，计算横向误差
    dx = RefPos(idx,1) -state(1);
    dy = RefPos(idx,2) -state(2);
    phi_r = RefHeading(idx);
%     latError = dy*cos(phi_r) - dx*sin(phi_r);
    latError = dy*cos(state(3)) - dx*sin(state(3));   % 应当使用实际航向角计算横向误差
    
    % 分别计算只考虑航向误差的theta和只考虑横向误差的theta
    theta_fai =  RefHeading(idx)- state(3);
    theta_y = atan2(k*latError,state(4));
    
    % 将两个角度合并即为前轮转角
    delta = theta_fai + theta_y;
end

function state_new = UpdateState(a,state_old,delta,dt,L)
    state_new(1) =  state_old(1) + state_old(4)*cos(state_old(3))*dt; %纵向坐标
    state_new(2) =  state_old(2) + state_old(4)*sin(state_old(3))*dt; %横向坐标
    state_new(3) =  state_old(3) + state_old(4)*dt*tan(delta)/L;      %航向角
    state_new(4) =  state_old(4) + a*dt;                              %纵向速度
end
